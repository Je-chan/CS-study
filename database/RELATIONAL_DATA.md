# 1. 데이터 모델링
- 현실에 존재하는 데이터를 컴퓨터 세계의 데이터베이스로 옮기는 과정
- 데이터베이스 설꼐의 핵심 과정
- 현실 세계 => (개념적 모델링) => 개념적 데이터 모델 => (논리적 모델링) => 논리적 데이터 모델 => (물리적 데이터 모델링) => 데이터 베이스

## 1-1) 데이터 모델링 3단계
### 개념적 데이터 모델링
- 현실 세계를 추상화 하여 데이터를 개념 세계로 추출해 가는 과정
- 결과물로 개념적 데이터 모델
- E-R 모델 (객체 - 관계 모델) : Entity 와 Relation
- Entity : 각각의 속성을 갖고 있는 것. (이름, 연락, 아이디, 주문 데이터 관계)
- Relation : 그 각 Entity 간에 관계를 만들어내는 것
        
### 논리적 데이터 모델링
- 개념 세계의 데이터를 데이터베이스가 저장할 구조로 변환
- 결과물로 관계 데이터 모델
- 실질적으로 데이터베이스를 만드는 과정
        
### 물리적 데이터 모델링
- 논리 데이터 모델이 실제 데이터베이스 저장소에 저장되는 저장 구조
- 데이터베이스가 제공하는 언어로 스키마 등을 Define 하는 것

### 예시
- 고객의 데이터 정보 저장하기
- 개념적 데이터 모델링 (E-R)
  - 고객 => 아이디, 이름, 연락처, 주소
- 논리적 데이터 모델링
  - 아이디 (CHAR 10), 이름 (CHAR 10), ...
        
        
        
# 2. 관계 데이터 모델
- 개체에 대한 데이터를 저장하는 논리적 구조. 
- Relation (2차원 테이블 구조)
- 2차원의 테이블 구조인데, 속성(Attribute)을 컬럼으로 표현하고, 각 컬럼이 Attirbute 를 저장
- Rlation 은 스키마와 인스턴스로 구성된다
- Relation 스키마는 속성의 이름과 속성이 가질 수 있는 데이터의 타입(도메인)을 표현
- 하나의 속성들의 유일한 값들을 튜플이라고 한다. 
  - 이 튜플의 집합을 릴레이션의 인스턴스라고 한다
- Special Value : null => 값이 없다가 아니라, 어떤 값인지 모른다는 의미

## 2-1) Relation 의 특성
- 튜플의 유일성 : 동일한 튜플이 존재할 수 없다
  - 각각의 속성은 같은 Value 를 가질 수 있지만 집합으로 봤을 때는 유니크해야 한다.
- 튜플의 무순서 : 튜플 사이의 순서는 무의미
- 속성(어트리뷰트) 무순서 : 속성 사이의 순서도 무의미
- 속성의 원자성 : 속성은 하나의 값만 가진다. (더이상 쪼개지지 않고 여러 값을 포함할 수 없다)
        
        
## 2-2) Key 의 종류
- Relation 에 튜플을 구별하는 역할을 하는 속성 또는 속성의 집합
- 튜플을 구별하기 위한 값. 
- 키의 종류에는 4 가지가 있다
### Super Key
- 튜플을 구별하기 위해 유일성을 제공할 수 있는 속성 또는 속성의 집합
- {ID}, {ID, name}

### Candidate Key
- Super Key 중에서 속성의 개수가 가장 작은 키
- 가장 적은 양의 데이터를 사용하면서 구별해낼 수 있는 것
- {ID}

### Primary Key
- 디자인 관점에서, Relation 간의 관계를 고려했을 때, 그 데이터의 타입을 고려했을 때 
- Cadnidate Key 중 가장 역할을 잘 해낼 키로 선택한 것

### Foreign Key
- 다른 Relation의 Primary Key 를 참조하는 속성, 또는 속성의 집합
        
        
## 2-3) 관계 데이터 모델의 제약 조건
### 도메인 무결성 제약 조건 (Domain integrity constraint)
- 릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만 가져야 한다
- 즉 데이터 타입, 데이터의 리스트에 속한 타입만 속성 값으로 가질 수 있다

### 개체 무결성 제약 조건 (Entity integrty constraint = primary key constraint) 
- 기본키를 구성하는 모든 속성은 Null 을 가질 수 없다

### 참조 무결성 제약 조건 (Referential integrity constraint = foreign key constraint)
- Foreign Key 는 참조하는 Relation의 Primary Key 속성 값 중 하나여야 한다. 
- 여기서는 Null 가능
        


# 3. 관계 대수 (Realtional Algebra)
## 3-1) 관계 데이터 연산
- Relation 에서 그것들 간에 필요한 정보를 얻어내는 연산식을 기술하는 언어
- DBMS 는 데이터 처리를 위해 하나 이상의 데이터 언어를 제공한다
- 첫 번째, Formal Query Language
  - 수학 기호를 사용해 데이터 처리를 기술한 언어
  - SQL과 같은 언어가 등장을 할 때, 그 언어의 유용성을 검증하는 기준이 된다
  - 그 중의 하나가 Relational Algebra
  
- 두 번째, Commercial Language
  - 수학적인 언어를 기반으로 사용하기 쉽게 만들어진 언어
  - 관계 대수로 만들어진 모든 질의가 표현 가능하다. 
  - SQL 이 이 언어에 해당

## 3-2) 관계 대수 연산자
- 피연산자로 하나 또는 두 개의 Relation
- 각 연산자의 연산 결과는 새로운 릴레이션을 만든다
- 숫자와 숫자를 연산하면 새로운 숫자를 만들듯이 릴레이션끼리 연산하면 릴레이션을 만들어 내는 것

- 연산자의 종류
  - select, project, union, difference, intersection
  - cartesian product, natural join, theta join, outer join

### <1> Select
- 수학적 기호로 시그마 노테이션을 사용한다.
- 여기서 p는 비교 연산자, 논리연산자를 이용해 속성 값을 비교하는 식을 만들어 낸다
- 릴레이션 하나만 가지고 동작하는 Unary Operation
- Select operation 은 Select 문에서 Where 조건을 쓰면서 만드는 것과 동일한 식이라고 보면 된다
        


### <2> Project
- 수학적 기호로 파이 노테이션을 사용
- 릴레이션 하나만 가지고 동작하는 Unary Operation
- 튜플들 중에서 리스트에 포함된 어트리뷰트만 포함되는 새로운 릴레이션을 만들어 낸다
- 릴레이션은 튜플의 유일성을 지니므로 동일한 Value를 갖고 있다면 중복을 제거한다
        
        

### <3> Union
- 수학적 기호로 합집합의 노테이션을 사용
- 합쳐서 릴레이션을 만든다 
- 두 개의 피연산자가 사용되는 Binary Operation
- Union 을 하기 위한 두 가지 조건
  - 두 릴레이션의 속성 개수가 같아야 하고,
  - 대응되는 속성의 도메인이 같아야 한다
        
        
### <4> Difference
- 수학적 기호로 차집합의 노테이션을 사용
- Binary Operation
- Difference 를 하기 위한 두 가지 조건 (합집합과 동일)
  - 두 릴레이션의 속성 개수가 같아야 하고,
  - 대응되는 속성의 도메인이 같아야 한다
       
       
### <5> Intersection
- 수학적 기호로 교집합의 노테이션을 사용
- Binary Operation
- Intersection 을 하기 위한 두 가지 조건 (합집합과 동일)
  - 두 릴레이션의 속성 개수가 같아야 하고,
  - 대응되는 속성의 도메인이 같아야 한다
        
        
### <6> Cartesian Product
- 수학적 기호로 곱하기 노테이션 사용
- 두 릴레이션이 있을 때 모든 값들을 곱해서 릴레이션을 만드는 것
- 두 릴레이션이 갖고 있는 튜플을 합쳐서 하나의 릴레이션을 만들고 싶은 것
- 여기서 조건을 추가해서 나오는 결과가 Join Operation 
        
        
### <7> Natural Join
- 수학적 기호로 나비넥타이 기호를 노테이션으로 사용
- 풀어 쓰면 교집합과 차집합으로 이뤄져 있다
- 결국은 두 개의 릴레이션을 합쳐서 같은 속성 값을 갖고 있는 것을 묶는다
        
        
### <8> Theta Join
- 수학적 기호로 나비넥타이 기호와 쎄타가 붙는 기호를 노테이션으로 사용
- Natural Join으로 만든 것 중에서 추가적인 쎄타 조건에 맞는 것만을 가져온다. (Select 의 개념이 들어간다)
- 조건에 맞지 않는 데이터들은 사라지게 된다
        
        
### <9> Outer Join
- Theta Join 을 하면 사라지는 정보가 존재함 그 정보들을 보완하기 위한 확장 버전
- 쎄타 조인을 먼저 하고, 한 릴레이션에서 제외된 모든 튜플을 조인된 결과의 릴레이션에 추가하는 것
- Left : 왼쪽 릴레이션의 튜플을 추가하는 것
- Right : 오른쪽 릴레이션의 튜플을 추가하는 것
- Full : 모든 릴레이션의 튜플을 추가하는 것
        
        
